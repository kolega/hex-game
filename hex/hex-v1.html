<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hex –¢–æ—á–∫–∏ ‚Äî —Ä–µ–±—Ä–æ 5</title>
  <style>
    :root {
      color-scheme: dark light;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #0f1115;
      color: #e6e6e6;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    .topbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 48px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0 16px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0));
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      z-index: 2;
      user-select: none;
    }

    .title {
      font-weight: 600;
      letter-spacing: 0.3px;
      color: #f0f3ff;
    }

    .spacer {
      flex: 1;
    }

    .btn {
      background: #2a3140;
      color: #e6ecff;
      border: 1px solid #3a4256;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn:hover {
      background: #323a4c;
    }

    .score {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 600;
      font-size: 14px;
      opacity: 0.95;
    }

    .badge {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #2f3650;
      background: #141925;
    }

    .p {
      color: #8fb5ff;
    }

    .e {
      color: #ff9f9f;
    }

    .muted {
      opacity: 0.7;
      font-weight: 500;
    }

    #game {
      position: absolute;
      inset: 0;
      top: 48px;
    }

    canvas {
      width: 100%;
      height: calc(100% - 48px);
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 48px 0 0 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 3;
    }

    .overlay.visible {
      display: flex;
    }

    .card {
      background: #141925;
      border: 1px solid #2f3650;
      padding: 24px 28px;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      text-align: center;
    }

    .card h2 {
      margin: 0 0 8px 0;
    }

    .subtitle {
      opacity: 0.8;
      margin-bottom: 16px;
    }

    .rules {
      position: fixed;
      bottom: 12px;
      left: 12px;
      background: rgba(20, 25, 37, 0.7);
      border: 1px solid #2a3148;
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 13px;
      line-height: 1.35;
      user-select: none;
      pointer-events: none;
      max-width: 44ch;
    }

    .rules b {
      color: #d7e0ff;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="title">Hex –¢–æ—á–∫–∏ ‚Äî —Ä–µ–±—Ä–æ 5</div>
    <div class="score" id="score">
      <span class="badge p">–ò–≥—Ä–æ–∫: <span id="scoreP">0</span></span>
      <span class="badge e">–í—Ä–∞–≥: <span id="scoreE">0</span></span>
      <span class="badge muted">–í—Å–µ–≥–æ —Ç–æ—á–µ–∫: <span id="scoreTotal">0</span></span>
      <span class="badge muted">–û—Å—Ç–∞–ª–æ—Å—å: <span id="scoreLeft">0</span></span>
    </div>
    <div class="spacer"></div>
    <button id="resetBtn" class="btn" title="–û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ –∏ –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ">–°–±—Ä–æ—Å</button>
  </div>

  <div id="game">
    <canvas id="canvas"></canvas>
    <div id="overlay" class="overlay">
      <div class="card">
        <h2>–ü–æ–±–µ–¥–∞! üéâ</h2>
        <div class="subtitle">–í—Å–µ –≥–µ–∫—Å—ã –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –ø–æ 3 —Ç–æ—á–∫–∏</div>
        <button id="againBtn" class="btn">–°—ã–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
      </div>
    </div>
  </div>

  <div class="rules">
    <div><b>–ü—Ä–∞–≤–∏–ª–∞</b></div>
    <div>1) –ü–æ–ª–µ ‚Äî –≥–µ–∫—Å –∏–∑ –º–∞–ª–µ–Ω—å–∫–∏—Ö –≥–µ–∫—Å–æ–≤, –¥–ª–∏–Ω–∞ —Ä–µ–±—Ä–∞ 5</div>
    <div>2) –•–æ–¥—ã –ø–æ –æ—á–µ—Ä–µ–¥–∏: –∏–≥—Ä–æ–∫ (—Å–∏–Ω–∏–π), –∑–∞—Ç–µ–º –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫ (–∫—Ä–∞—Å–Ω—ã–π)</div>
    <div>3) –ö–ª–∏–∫/—Ö–æ–¥ –¥–æ–±–∞–≤–ª—è–µ—Ç 1 —Ç–æ—á–∫—É (–¥–æ 3)</div>
    <div>4) –ù–∞ 4-–π —Ç–æ—á–∫–µ –≥–µ–∫—Å —Ä–∞—Å–ø–∞–¥–∞–µ—Ç—Å—è –Ω–∞ 3 —Å–ª—É—á–∞–π–Ω—ã—Ö —Å–æ—Å–µ–¥–Ω–∏—Ö, —Å–∞–º —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è 1 –∏ –æ–∫—Ä–∞—à–∏–≤–∞–µ—Ç—Å—è –≤ —Ü–≤–µ—Ç —Ç–µ–∫—É—â–µ–≥–æ
      –∏–≥—Ä–æ–∫–∞</div>
    <div>5) –ö–∞—Å–∫–∞–¥: –µ—Å–ª–∏ —Å–æ—Å–µ–¥ –∏–º–µ–ª 3, –æ–Ω —Ç–æ–∂–µ —Ä–∞—Å–ø–∞–¥–∞–µ—Ç—Å—è (—Ä–æ–¥–∏—Ç–µ–ª—å –∏—Å–∫–ª—é—á–∞–µ—Ç—Å—è), –º–∞–∫—Å–∏–º—É–º 3 —Ü–∏–∫–ª–∞ –∑–∞ —Ö–æ–¥</div>
    <div>6) –ü–æ–±–µ–¥–∞ ‚Äî –∫–æ–≥–¥–∞ –≤—Å–µ –≥–µ–∫—Å—ã –∏–º–µ—é—Ç –ø–æ 3 —Ç–æ—á–∫–∏</div>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const overlay = document.getElementById('overlay');
      const resetBtn = document.getElementById('resetBtn');
      const againBtn = document.getElementById('againBtn');

      // –ì–µ–∫—Å-—Ñ–æ—Ä–º–∞: –¥–ª–∏–Ω–∞ —Ä–µ–±—Ä–∞
      const SIDE = 5;            // —á–∏—Å–ª–æ —è—á–µ–µ–∫ –ø–æ —Ä–µ–±—Ä—É
      const RADIUS = SIDE - 1;   // —Ä–∞–¥–∏—É—Å –≤ –∞–∫—Å–∏–∞–ª—å–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö

      let deviceScale = Math.max(1, window.devicePixelRatio || 1);
      let hexR = 24;             // –ø–∏–∫—Å–µ–ª—å–Ω—ã–π —Ä–∞–¥–∏—É—Å (—Ü–µ–Ω—Ç—Ä -> –≤–µ—Ä—à–∏–Ω–∞)
      const padding = 24;

      // –ê–∫—Å–∏–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (q, r) –¥–ª—è –≥–µ–∫—Å–∞ —Ä–∞–¥–∏—É—Å–∞ RADIUS
      const cells = [];
      for (let q = -RADIUS; q <= RADIUS; q++) {
        const r1 = Math.max(-RADIUS, -q - RADIUS);
        const r2 = Math.min(RADIUS, -q + RADIUS);
        for (let r = r1; r <= r2; r++) {
          cells.push({ q, r });
        }
      }

      const keyOf = (q, r) => `${q},${r}`;

      // –°–æ—Å—Ç–æ—è–Ω–∏–µ: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –∏ –≤–ª–∞–¥–µ–ª–µ—Ü –∫–∞–∂–¥–æ–π —è—á–µ–π–∫–∏
      const counts = new Map();
      const owners = new Map(); // 'P' | 'E' | null
      const paths = new Map();
      let hoveredKey = null;
      let currentPlayer = 'P'; // 'P' ‚Äî –∏–≥—Ä–æ–∫ (—Å–∏–Ω–∏–π), 'E' ‚Äî –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫ (–∫—Ä–∞—Å–Ω—ã–π)
      let inputLocked = false;
      for (const { q, r } of cells) {
        const k = keyOf(q, r);
        counts.set(k, 0);
        owners.set(k, null);
      }

      const scoreP = document.getElementById('scoreP');
      const scoreE = document.getElementById('scoreE');
      const scoreTotal = document.getElementById('scoreTotal');
      const scoreLeft = document.getElementById('scoreLeft');

      function computeScores() {
        let p = 0, e = 0, total = 0;
        for (const { q, r } of cells) {
          const k = keyOf(q, r);
          const c = counts.get(k) || 0;
          total += c;
          const o = owners.get(k);
          if (o === 'P') p += c;
          else if (o === 'E') e += c;
        }
        const maxTotal = cells.length * 3;
        return { p, e, total, left: Math.max(0, maxTotal - total) };
      }

      function updateScoreUI() {
        const { p, e, total, left } = computeScores();
        if (scoreP) scoreP.textContent = String(p);
        if (scoreE) scoreE.textContent = String(e);
        if (scoreTotal) scoreTotal.textContent = String(total);
        if (scoreLeft) scoreLeft.textContent = String(left);
      }

      function resizeCanvasToDisplaySize() {
        const parent = canvas.parentElement;
        const cssWidth = parent.clientWidth;
        const cssHeight = parent.clientHeight;
        deviceScale = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.floor(cssWidth * deviceScale);
        canvas.height = Math.floor(cssHeight * deviceScale);
        canvas.style.width = cssWidth + 'px';
        canvas.style.height = cssHeight + 'px';
      }

      // –¶–µ–Ω—Ç—Ä—ã –≥–µ–∫—Å–æ–≤ –≤ –ø–∏–∫—Å–µ–ª—è—Ö –¥–ª—è flat-top: x = 1.5*hexR*q, y = sqrt(3)*hexR*(r + q/2)
      function axialToPixel(q, r, hexR, originX, originY) {
        const x = originX + (1.5 * hexR) * q;
        const y = originY + (Math.sqrt(3) * hexR) * (r + 0.5 * q);
        return { x, y };
      }

      function buildHexPath(cx, cy, radius) {
        const a = radius; // –ø–æ –æ—Å–∏ X –¥–æ –≤–µ—Ä—à–∏–Ω—ã
        const b = (Math.sqrt(3) / 2) * radius; // –ø–æ –æ—Å–∏ Y –¥–æ —É–≥–ª–∞
        const path = new Path2D();
        path.moveTo(cx - a, cy);
        path.lineTo(cx - a / 2, cy - b);
        path.lineTo(cx + a / 2, cy - b);
        path.lineTo(cx + a, cy);
        path.lineTo(cx + a / 2, cy + b);
        path.lineTo(cx - a / 2, cy + b);
        path.closePath();
        return path;
      }

      const DIRS = [
        [1, 0], [1, -1], [0, -1],
        [-1, 0], [-1, 1], [0, 1],
      ];
      function neighbors(q, r) {
        const res = [];
        for (const [dq, dr] of DIRS) {
          const nq = q + dq, nr = r + dr;
          if (counts.has(keyOf(nq, nr))) res.push([nq, nr]);
        }
        return res;
      }
      function shuffleInPlace(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function computeLayoutAndSize() {
        // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã —Ü–µ–Ω—Ç—Ä–æ–≤ –ø—Ä–∏ hexR=1
        const xCoeffs = cells.map(({ q }) => 1.5 * q);
        const yCoeffs = cells.map(({ q, r }) => Math.sqrt(3) * (r + 0.5 * q));
        const minXC = Math.min(...xCoeffs);
        const maxXC = Math.max(...xCoeffs);
        const minYC = Math.min(...yCoeffs);
        const maxYC = Math.max(...yCoeffs);

        const rangeXC = maxXC - minXC;              // —à–∏—Ä–∏–Ω–∞ —Ü–µ–Ω—Ç—Ä–æ–≤ –≤ –µ–¥–∏–Ω–∏—Ü–∞—Ö hexR
        const rangeYC = maxYC - minYC;              // –≤—ã—Å–æ—Ç–∞ —Ü–µ–Ω—Ç—Ä–æ–≤ –≤ –µ–¥–∏–Ω–∏—Ü–∞—Ö hexR

        const availW = Math.max(1, canvas.width - 2 * padding * deviceScale);
        const availH = Math.max(1, canvas.height - 2 * padding * deviceScale);

        // –ü–æ–ª–Ω–∞—è —à–∏—Ä–∏–Ω–∞ = hexR * (rangeXC + 2)  (–∑–∞–ø–∞—Å –ø–æ ¬±hexR)
        // –ü–æ–ª–Ω–∞—è –≤—ã—Å–æ—Ç–∞ = hexR * (rangeYC + sqrt(3)) (–∑–∞–ø–∞—Å –ø–æ ¬±sqrt(3)/2 —Å–≤–µ—Ä—Ö—É –∏ —Å–Ω–∏–∑—É)
        const hexRbyW = availW / (rangeXC + 2);
        const hexRbyH = availH / (rangeYC + Math.sqrt(3));
        hexR = Math.floor(Math.max(8, Math.min(hexRbyW, hexRbyH)));

        const totalW = hexR * (rangeXC + 2);
        const totalH = hexR * (rangeYC + Math.sqrt(3));

        const edgeLeft = padding * deviceScale + (availW - totalW) / 2;
        const edgeTop = padding * deviceScale + (availH - totalH) / 2;

        // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Ü–µ–Ω—Ç—Ä–∞ –ª—é–±–æ–π —è—á–µ–π–∫–∏
        return function centerOf(q, r) {
          const cx = edgeLeft + hexR + (1.5 * q - minXC) * hexR;
          const cy = edgeTop + (Math.sqrt(3) / 2) * hexR + (Math.sqrt(3) * (r + 0.5 * q) - minYC) * hexR;
          return { x: cx, y: cy };
        };
      }

      function drawDots(cx, cy, radius, count, color) {
        if (count <= 0) return;
        const r = Math.max(2, Math.floor(radius * 0.22));
        ctx.fillStyle = color;
        if (count === 1) {
          dot(cx, cy, r);
        } else if (count === 2) {
          const dx = radius * 0.6;
          dot(cx - dx / 2, cy, r);
          dot(cx + dx / 2, cy, r);
        } else if (count === 3) {
          const dx = radius * 0.6;
          const dy = (Math.sqrt(3) / 2) * radius * 0.5;
          dot(cx, cy - dy, r);
          dot(cx - dx / 2, cy + dy * 0.7, r);
          dot(cx + dx / 2, cy + dy * 0.7, r);
        }
      }
      function dot(x, y, r) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const centerOf = computeLayoutAndSize();
        paths.clear();

        for (const { q, r } of cells) {
          const { x, y } = centerOf(q, r);
          const path = buildHexPath(x, y, hexR);
          const k = keyOf(q, r);
          paths.set(k, path);

          const count = counts.get(k) || 0;
          const owner = owners.get(k);

          // –ü–∞–ª–∏—Ç—Ä—ã: P ‚Äî —Å–∏–Ω–∏–π, E ‚Äî –∫—Ä–∞—Å–Ω—ã–π, null ‚Äî —Å–µ—Ä–æ-—Å–∏–Ω–∏–π
          const isHovered = hoveredKey === k;
          const stroke = isHovered ? '#b6c4ff' : '#3a4769';

          // –§–æ–Ω –≥–µ–∫—Å–∞ ‚Äî –Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π, –Ω–µ –æ–∫—Ä–∞—à–∏–≤–∞–µ–º –≤ —Ü–≤–µ—Ç –≤–ª–∞–¥–µ–ª—å—Ü–∞
          ctx.fillStyle = 'rgba(36, 43, 66, 0.18)';
          ctx.strokeStyle = stroke;
          ctx.lineWidth = Math.max(1, Math.floor(hexR * 0.09));
          ctx.fill(path);
          ctx.stroke(path);

          // –¢–æ—á–∫–∏ —Ü–≤–µ—Ç–æ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞
          ctx.save();
          const dotColor = owner === 'P' ? '#8fb5ff' : owner === 'E' ? '#ff9f9f' : '#dfe6ff';
          drawDots(x, y, hexR, count, dotColor);
          ctx.restore();
        }
        updateScoreUI();
      }

      function allFilledToThree() {
        for (const k of counts.keys()) {
          if (counts.get(k) !== 3) return false;
        }
        return true;
      }
      function showWinOverlay() { overlay.classList.add('visible'); }
      function hideWinOverlay() { overlay.classList.remove('visible'); }

      function reset() {
        for (const k of counts.keys()) counts.set(k, 0);
        for (const k of owners.keys()) owners.set(k, null);
        currentPlayer = 'P';
        inputLocked = false;
        hideWinOverlay();
        draw();
        updateScoreUI();
      }

      function addPoint(q, r, depthLeft, parentKey, fromSplit) {
        const k = keyOf(q, r);
        const cur = counts.get(k) || 0;

        if (cur < 3) {
          counts.set(k, cur + 1);
          // –ø—Ä–∏ —Å–ø–ª–∏—Ç–µ –ø–µ—Ä–µ–∫—Ä–∞—à–∏–≤–∞–µ–º —è—á–µ–π–∫—É –≤ —Ü–≤–µ—Ç —Ä–æ–¥–∏—Ç–µ–ª—è; –∏–Ω–∞—á–µ, –µ—Å–ª–∏ –ø—É—Å—Ç–∞—è ‚Äî –Ω–∞–∑–Ω–∞—á–∞–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞
          if (fromSplit) {
            owners.set(k, currentPlayer);
          } else if (owners.get(k) == null) {
            owners.set(k, currentPlayer);
          }
          return;
        }

        if (depthLeft <= 0) {
          return;
        }

        // —Ä–∞—Å–ø–∞–¥: —Ç–µ–∫—É—â–∞—è —è—á–µ–π–∫–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è 1 –∏ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ü–≤–µ—Ç —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
        counts.set(k, 1);
        owners.set(k, currentPlayer);

        // –≤—ã–±–∏—Ä–∞–µ–º –¥–æ 3 —Å–ª—É—á–∞–π–Ω—ã—Ö —Å–æ—Å–µ–¥–µ–π (–∫—Ä–æ–º–µ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–≥–æ)
        const neighs = neighbors(q, r).filter(([nq, nr]) => keyOf(nq, nr) !== parentKey);
        shuffleInPlace(neighs);
        const targets = neighs.slice(0, Math.min(3, neighs.length));
        for (const [nq, nr] of targets) {
          addPoint(nq, nr, depthLeft - 1, k, true);
        }
      }

      function enemyMove() {
        // –ò–ò: –≤—ã–±–∏—Ä–∞–µ—Ç —Å–ª—É—á–∞–π–Ω—É—é –ø—É—Å—Ç—É—é –∏–ª–∏ —Å–≤–æ—é —è—á–µ–π–∫—É (–Ω–µ –∏–≥—Ä–æ–∫–∞) —Å count < 3
        const candidates = [];
        for (const { q, r } of cells) {
          const k = keyOf(q, r);
          const c = counts.get(k) || 0;
          const o = owners.get(k);
          if (c < 3 && (o === 'E' || o == null)) candidates.push({ q, r });
        }
        if (candidates.length === 0) return;
        const idx = Math.floor(Math.random() * candidates.length);
        const { q, r } = candidates[idx];
        addPoint(q, r, 3, null, false);
      }

      function handleClick(evt) {
        if (inputLocked) return;
        const rect = canvas.getBoundingClientRect();
        const x = (evt.clientX - rect.left) * deviceScale;
        const y = (evt.clientY - rect.top) * deviceScale;

        let hitKey = null;
        for (const [k, path] of paths.entries()) {
          if (path && ctx.isPointInPath(path, x, y)) { hitKey = k; break; }
        }
        if (!hitKey) return;

        const [qStr, rStr] = hitKey.split(',');
        const q = parseInt(qStr, 10);
        const r = parseInt(rStr, 10);

        // –ó–∞–ø—Ä–µ—â–∞–µ–º –∫–ª–∏–∫ –ø–æ –≤—Ä–∞–∂–µ—Å–∫–æ–π —è—á–µ–π–∫–µ (–º–æ–∂–Ω–æ —Ö–æ–¥–∏—Ç—å —Ç–æ–ª—å–∫–æ –ø–æ —Å–≤–æ–∏–º –∏–ª–∏ –ø—É—Å—Ç—ã–º)
        const cellOwner = owners.get(hitKey);
        if (cellOwner && cellOwner !== 'P') return;

        // –•–æ–¥ –∏–≥—Ä–æ–∫–∞ (—Å–∏–Ω–∏–π)
        currentPlayer = 'P';
        addPoint(q, r, 3, null, false);
        draw();
        updateScoreUI();
        if (allFilledToThree()) { showWinOverlay(); return; }

        // –•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–∫—Ä–∞—Å–Ω—ã–π)
        inputLocked = true;
        setTimeout(() => {
          currentPlayer = 'E';
          enemyMove();
          draw();
          updateScoreUI();
          inputLocked = false;
          if (allFilledToThree()) showWinOverlay();
        }, 200);
      }

      function handleMove(evt) {
        const rect = canvas.getBoundingClientRect();
        const x = (evt.clientX - rect.left) * deviceScale;
        const y = (evt.clientY - rect.top) * deviceScale;

        let newHover = null;
        for (const [k, path] of paths.entries()) {
          if (path && ctx.isPointInPath(path, x, y)) { newHover = k; break; }
        }
        if (newHover !== hoveredKey) {
          hoveredKey = newHover;
          draw();
        }
      }
      function handleLeave() {
        if (hoveredKey !== null) {
          hoveredKey = null;
          draw();
        }
      }

      // init
      function init() {
        resizeCanvasToDisplaySize();
        draw();
      }

      window.addEventListener('resize', () => { resizeCanvasToDisplaySize(); draw(); });
      canvas.addEventListener('click', handleClick);
      canvas.addEventListener('mousemove', handleMove);
      canvas.addEventListener('mouseleave', handleLeave);
      resetBtn.addEventListener('click', reset);
      againBtn.addEventListener('click', reset);

      init();
    })();
  </script>
</body>

</html>